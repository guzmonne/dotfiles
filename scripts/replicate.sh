#!/usr/bin/env bash
# This script was generated by rargs 0.0.0 (https://rargs.cloudbridge.uy)
# Modifying it manually is not recommended

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

if [[ -n "${DEBUG:-}" ]]; then
  set -x
fi
set -e


normalize_rargs_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      rargs_input+=("${BASH_REMATCH[1]}")
      rargs_input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      rargs_input+=("${BASH_REMATCH[1]}")
      rargs_input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        rargs_input+=("-${flags:i:1}")
      done
    else
      rargs_input+=("$arg")
    fi

    shift
  done
}

trap handle_exit SIGINT
REPLICATE_API_PREDICTIONS_URL="https://api.replicate.com/v1/predictions"
REPLICATE_CHATML_SYSTEM_PROMPT_TEMPLATE='<|im_start|>system ${SYSTEM_PROMPT}<|im_end|> <|im_start|>user {prompt}<|im_end|> <|im_start|>assistant:'
REPLICATE_LLAMA3_SYSTEM_PROMPT_TEMPLATE='<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n${SYSTEM_PROMPT}<|eot_id|><|start_header_id|>user<|end_header_id|>\n\n{prompt}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n'
REPLICATE_LLAMA2_SYSTEM_PROMPT_TEMPLATE='[INST] {prompt} [/INST]\n'
REPLICATE_MISTRAL_SYSTEM_PROMPT_TEMPLATE='<|system|>\n${SYSTEM_PROMPT}</s>\n<|user|>\n{prompt}</s>\n<|assistant|>\n'
REPLICATE_DOLPHIN_SYSTEM_PROMPT_TEMPLATE='<|im_start|>system\n${SYSTEM_PROMPT}\n<|im_end|>\n<|im_start|>user\n{prompt}<|im_end|>\n<|im_start|>assistant\n'
REPLICATE_FALCON_SYSTEM_PROMPT_TEMPLATE='{prompt}'
REPLICATE_CANCEL_URL=""
handle_exit() {
	printf "\r\033[K[SININT] Exiting...\n" >&2
	printf "%s" "$REPLICATE_CANCEL_URL" >&2
	if [[ -n "$REPLICATE_CANCEL_URL" ]]; then
		echo "Cancelling request... $REPLICATE_CANCEL_URL" >&2
		curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$REPLICATE_CANCEL_URL" >&2
	fi
	kill -- -$$
	exit 1
}

version() {
  echo -n "0.1.0"
}
usage() {
  printf "Utility functions to interact with replicate.\n"
  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  replicate.sh [OPTIONS] [COMMAND] [COMMAND_OPTIONS]\n"
  printf "  replicate.sh -h|--help\n"
  printf "  replicate.sh --version\n"
  printf "\n\033[4m%s\033[0m\n" "Commands:"
  cat <<EOF
  airoboros-llama-2-70b ....... Expose the airoboros model through Replicate
  causallm-14b ................ Expose the Causal-LM model through Replicate
  codellama-34b-instruct ...... Expose the codellama-34b-instruct model through Replicate
  deepseek-r1 ................. Run the DeepSeek R1 model from Replicate
  dolphin-2.2.1-mistral-7b .... Expose the dolphin-2.2.1-mistral-7b model through Replicate
  dolphin29 ................... Expose the dolphin-2.9-llama3-70b-gguf model through Replicate
  falcon-40b-instruct ......... Expose the falcon-40b-instruct model through Replicate
  llama2-70b .................. Expose the llama2-70b model through Replicate
  llama3-70b .................. Expose the llama2-70b model through Replicate
  mistral-7b-instruct-v0.1 .... Expose the mistral-7b-instruct-v0.1 through Replicate
  mistral-7b-openorca ......... Expose the mistral-7b-openorca model through Replicate
  openhermes-2-mistral-7b ..... Expose the openhermes-2-mistral-7b model through Replicate
  zephyr-7b-beta .............. Expose the Zephyr-7b-beta model through Replicate
EOF
  printf "  [@default api]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
  printf "  --version\n"
  printf "    Print version\n"
}

parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version)
        version
        exit
        ;;
      *)
        break
        ;;
    esac
  done
  action="${1:-}"

  case $action in
    airoboros-llama-2|airoboros|airoboros-llama-2-70b)
      action="airoboros-llama-2-70b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    api)
      action="api"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    causallm|causal|causallm-14b)
      action="causallm-14b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    codellama-34b|codellama|codellama-34b-instruct)
      action="codellama-34b-instruct"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    deepseek-r1)
      action="deepseek-r1"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    dolphin-mistral-7b|dolphin-mistral|dolphin-2.2.1-mistral-7b)
      action="dolphin-2.2.1-mistral-7b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    dolphin29|dolphin29)
      action="dolphin29"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    falcon-40b|falcon|falcon-40b-instruct)
      action="falcon-40b-instruct"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    llama2|llama2-70b)
      action="llama2-70b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    llama3|llama3-70b)
      action="llama3-70b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    long-pull)
      action="long-pull"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    mistral-7b-instruct|mistral-7b|mistral|mistral-7b-instruct-v0.1)
      action="mistral-7b-instruct-v0.1"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    openorca|mistral-7b-openorca)
      action="mistral-7b-openorca"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    openhermes-2-mistral|openhermes-2|openhermes|hermes|openhermes-2-mistral-7b)
      action="openhermes-2-mistral-7b"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request)
      action="request"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request-chatml)
      action="request-chatml"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request-dolphin)
      action="request-dolphin"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request-falcon)
      action="request-falcon"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request-llama)
      action="request-llama"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    request-mistral)
      action="request-mistral"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    spinner)
      action="spinner"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    zephyr-7b|zephyr|zephyr-7b-beta)
      action="zephyr-7b-beta"
      rargs_input=("${rargs_input[@]:1}")
      ;;
    -h|--help)
      usage
      exit
      ;;
    "")
      action="api"
      ;;
    *)
      action="api"
      ;;
  esac
}
airoboros-llama-2-70b_usage() {
  printf "Expose the airoboros model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "airoboros-llama-2, airoboros"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  airoboros-llama-2-70b [OPTIONS] PROMPT\n"
  printf "  airoboros-llama-2-70b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_airoboros-llama-2-70b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the airoboros model through Replicate
airoboros-llama-2-70b() {
  local rargs_raw
  local rargs_verbose
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_airoboros-llama-2-70b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    airoboros-llama-2-70b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    airoboros-llama-2-70b_usage >&2
    exit 1
  fi
	request-llama -m "ae090a64e6b4468d7fa85c6ca33c979b3cd941c12b1cfa2a237b4a7aa6ebaac4" "$@"
}
api_usage() {
  printf "Interact with the replicate API\n"
  printf "This command takes the union of options to configure multiple models. It's your responsibility to check that the model you want to use supports them.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  api -m|--model <MODEL> [OPTIONS] PROMPT\n"
  printf "  api -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  --debug [<DEBUG>]\n"
  printf "    Provide debugging output in logs.\n"
  printf "  --frequency-penalty [<FREQUENCY-PENALTY>]\n"
  printf "    The value used to penalize the frequency of words already present in the prompt.\n"
  printf "  --max-new-tokens [<MAX-NEW-TOKENS>]\n"
  printf "    Maximum number of tokens to generate.\n"
  printf "  --max-tokens [<MAX-TOKENS>]\n"
  printf "    Maximum number of tokens to generate.\n"
  printf "  --min-new-tokens [<MIN-NEW-TOKENS>]\n"
  printf "    Minimum number of tokens to generate.\n"
  printf "  --min-tokens [<MIN-TOKENS>]\n"
  printf "    Minimum number of tokens to generate.\n"
  printf "  -m --model <MODEL>\n"
  printf "    The model to use to generate the text.\n"
  printf "  --presence-penalty [<PRESENCE-PENALTY>]\n"
  printf "    The value used to penalize the presence of words already present in the prompt.\n"
  printf "  --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The template used to generate the prompt. The input prompt is inserted into the template using the '{prompt}' placeholder.\n"
  printf "  --seed [<SEED>]\n"
  printf "    Random seed.\n"
  printf "  --stop-sequences [<STOP-SEQUENCES>]\n"
  printf "    A comma-separated list of sequences to stop generation at.\n"
  printf "  --system-prompt [<SYSTEM-PROMPT>]\n"
  printf "    Text prepended to the prompt used to help guide or control the output.\n"
  printf "  -t --temperature [<TEMPERATURE>]\n"
  printf "    The value used to modulate the next token probabilities.\n"
  printf "  -k --top-k [<TOP-K>]\n"
  printf "    The number of highest probability tokens to consider for generatint the output.\n"
  printf "  -p --top-p [<TOP-P>]\n"
  printf "    A probability threshold for generating the output\n"
  printf "  --use-lora\n"
  printf "    Whether to use LoRa for prediction.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_api_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --use-lora)
        rargs_use_lora=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      --debug)
        rargs_debug="$2"
        shift 2
        ;;
      --frequency-penalty)
        rargs_frequency_penalty="$2"
        shift 2
        ;;
      --max-new-tokens)
        rargs_max_new_tokens="$2"
        shift 2
        ;;
      --max-tokens)
        rargs_max_tokens="$2"
        shift 2
        ;;
      --min-new-tokens)
        rargs_min_new_tokens="$2"
        shift 2
        ;;
      --min-tokens)
        rargs_min_tokens="$2"
        shift 2
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      --presence-penalty)
        rargs_presence_penalty="$2"
        shift 2
        ;;
      --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      --seed)
        rargs_seed="$2"
        shift 2
        ;;
      --stop-sequences)
        rargs_stop_sequences="$2"
        shift 2
        ;;
      --system-prompt)
        rargs_system_prompt="$2"
        shift 2
        ;;
      -t | --temperature)
        rargs_temperature="$2"
        shift 2
        ;;
      -k | --top-k)
        rargs_top_k="$2"
        shift 2
        ;;
      -p | --top-p)
        rargs_top_p="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Interact with the replicate API
# This command takes the union of options to configure multiple models. It's your responsibility to check that the model you want to use supports them.
api() {
  local rargs_use_lora
  local rargs_verbose
  local rargs_debug
  local rargs_frequency_penalty
  local rargs_max_new_tokens
  local rargs_max_tokens
  local rargs_min_new_tokens
  local rargs_min_tokens
  local rargs_model
  local rargs_presence_penalty
  local rargs_prompt_template
  local rargs_seed
  local rargs_stop_sequences
  local rargs_system_prompt
  local rargs_temperature
  local rargs_top_k
  local rargs_top_p
  local rargs_prompt
  # Parse environment variables
  
  if [[ -z "${REPLICATE_API_TOKEN:-}" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required environment variable: " "REPLICATE_API_TOKEN" >&2
    api_usage >&2
    exit 1
  fi


  # Parse command arguments
  parse_api_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    api_usage
    exit 0
  fi
  
  if [[ -z "$rargs_model" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "model" >&2
    api_usage >&2
    exit 1
  fi
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    api_usage >&2
    exit 1
  fi
	if [[ "$rargs_prompt" == "-" ]]; then
		rargs_prompt="$(cat -)"
	fi
	data="$(jo prompt="$rargs_prompt")"
	# Temperature
	if [[ -n "$rargs_temperature" ]]; then
		data="$(jo -f <(echo -n "$data") temperature="$rargs_temperature")"
	fi
	# Top-p
	if [[ -n "$rargs_top_p" ]]; then
		data="$(jo -f <(echo -n "$data") top_p="$rargs_top_p")"
	fi
	# Top-k
	if [[ -n "$rargs_top_k" ]]; then
		data="$(jo -f <(echo -n "$data") top_k="$rargs_top_k")"
	fi
	# Presence penalty
	if [[ -n "$rargs_presence_penalty" ]]; then
		data="$(jo -f <(echo -n "$data") presence_penalty="$rargs_presence_penalty")"
	fi
	# Frequency penalty
	if [[ -n "$rargs_frequency_penalty" ]]; then
		data="$(jo -f <(echo -n "$data") frequency_penalty="$rargs_frequency_penalty")"
	fi
	# Prompt template
	if [[ -n "$rargs_prompt_template" ]]; then
		data="$(jo -f <(echo -n "$data") prompt_template="$rargs_prompt_template")"
	fi
	# System prompt
	if [[ -n "$rargs_system_prompt" ]]; then
		data="$(jo -f <(echo -n "$data") system_prompt="$rargs_system_prompt")"
	fi
	# Min new tokens
	if [[ -n "$rargs_min_new_tokens" ]]; then
		data="$(jo -f <(echo -n "$data") min_new_tokens="$rargs_min_new_tokens")"
	fi
	# Max new tokens
	if [[ -n "$rargs_max_new_tokens" ]]; then
		data="$(jo -f <(echo -n "$data") max_new_tokens="$rargs_max_new_tokens")"
	fi
	# Max tokens
	if [[ -n "$rargs_max_tokens" ]]; then
		data="$(jo -f <(echo -n "$data") max_tokens="$rargs_max_tokens")"
	fi
	# Min tokens
	if [[ -n "$rargs_min_tokens" ]]; then
		data="$(jo -f <(echo -n "$data") min_tokens="$rargs_min_tokens")"
	fi
	# Stop sequences
	if [[ -n "$rargs_stop_sequences" ]]; then
		data="$(jo -f <(echo -n "$data") stop_sequences="$rargs_stop_sequences")"
	fi
	# Seed
	if [[ -n "$rargs_seed" ]]; then
		data="$(jo -f <(echo -n "$data") seed="$rargs_seed")"
	fi
	# Debug
	if [[ -n "$rargs_debug" ]]; then
		data="$(jo -f <(echo -n "$data") debug="$rargs_debug")"
	fi
	# Use LoRa
	if [[ -n "$rargs_use_lora" ]]; then
		data="$(jo -f <(echo -n "$data") use_lora=true)"
	fi
	response="$(curl -s -X POST \
		-H "Content-Type: application/json" \
		-d "$(jo version="$rargs_model" input="$data")" \
		-H "Authorization: Token $REPLICATE_API_TOKEN" \
		"$REPLICATE_API_PREDICTIONS_URL")"
	REPLICATE_CANCEL_URL="$(jq -r '.urls.cancel' <<<"$response")"
	if [[ -n "$rargs_verbose" ]]; then
		printf "\r\033[K%s\n" "$response" >&2
	fi
	timeout 120s "$0" long-pull "$(if [[ -n "$rargs_verbose" ]]; then echo "--verbose"; fi)" "$(jq -r '.urls.get' <<<"$response")" &
	local long_pull_pid=$!
	spinner "$long_pull_pid"
	wait $long_pull_pid
	local exit_status=$?
	if [[ "$exit_status" -eq 124 ]]; then
		printf "\r\033[KRequest timed out\n" >&2
		if [[ -n "$REPLICATE_CANCEL_URL" ]]; then
			printf "\r\033[KCancelling request... %s\n" "$REPLICATE_CANCEL_URL" >&2
			curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$REPLICATE_CANCEL_URL" >&2
		fi
	fi
}
causallm-14b_usage() {
  printf "Expose the Causal-LM model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "causallm, causal"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  causallm-14b [OPTIONS] PROMPT\n"
  printf "  causallm-14b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_causallm-14b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the Causal-LM model through Replicate
causallm-14b() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_causallm-14b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    causallm-14b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    causallm-14b_usage >&2
    exit 1
  fi
	request-chatml -m "ff2eae35d8ba6db73bdc8b73ecac84d8c97f970b63803927ac6de014560d986a" "$@"
}
codellama-34b-instruct_usage() {
  printf "Expose the codellama-34b-instruct model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "codellama-34b, codellama"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  codellama-34b-instruct [OPTIONS] PROMPT\n"
  printf "  codellama-34b-instruct -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_codellama-34b-instruct_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the codellama-34b-instruct model through Replicate
codellama-34b-instruct() {
  local rargs_raw
  local rargs_verbose
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_codellama-34b-instruct_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    codellama-34b-instruct_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    codellama-34b-instruct_usage >&2
    exit 1
  fi
	request-llama -m "b17fdb44c843000741367ae3d73e2bb710d7428a662238ddebbf4302db2b5422" "$@"
}
deepseek-r1_usage() {
  printf "Run the DeepSeek R1 model from Replicate\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  deepseek-r1 [OPTIONS] PROMPT\n"
  printf "  deepseek-r1 -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_deepseek-r1_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Run the DeepSeek R1 model from Replicate
deepseek-r1() {
  local rargs_verbose
  local rargs_prompt

  # Parse command arguments
  parse_deepseek-r1_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    deepseek-r1_usage
    exit 0
  fi
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    deepseek-r1_usage >&2
    exit 1
  fi
	prediction=$(
		curl --silent --show-error https://api.replicate.com/v1/models/deepseek-ai/deepseek-r1/predictions \
			--request POST \
			--header "Authorization: Bearer $REPLICATE_API_TOKEN" \
			--header "Content-Type: application/json" \
			--data "$(jo stream=true input="$(jo input="$rargs_prompt")")"
	)
	stream_url=$(printf "%s" "$prediction" | jq -r .urls.stream)
	curl --silent --show-error --no-buffer "$stream_url" \
		--header "Accept: text/event-stream" \
		--header "Cache-Control: no-store"
}
dolphin-2.2.1-mistral-7b_usage() {
  printf "Expose the dolphin-2.2.1-mistral-7b model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "dolphin-mistral-7b, dolphin-mistral"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  dolphin-2.2.1-mistral-7b [OPTIONS] PROMPT\n"
  printf "  dolphin-2.2.1-mistral-7b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_dolphin-2.2.1-mistral-7b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the dolphin-2.2.1-mistral-7b model through Replicate
dolphin-2.2.1-mistral-7b() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_dolphin-2.2.1-mistral-7b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    dolphin-2.2.1-mistral-7b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    dolphin-2.2.1-mistral-7b_usage >&2
    exit 1
  fi
	request-dolphin -m "0521a0090543fea1a687a871870e8f475d6581a3e6e284e32a2579cfb4433ecf" "$@"
}
dolphin29_usage() {
  printf "Expose the dolphin-2.9-llama3-70b-gguf model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "dolphin29"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  dolphin29 [OPTIONS] PROMPT\n"
  printf "  dolphin29 -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_dolphin29_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the dolphin-2.9-llama3-70b-gguf model through Replicate
dolphin29() {
  local rargs_raw
  local rargs_verbose
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_dolphin29_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    dolphin29_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    dolphin29_usage >&2
    exit 1
  fi
	request-llama -m "7cd1882cb3ea90756d09decf4bc8a259353354703f8f385ce588b71f7946f0aa" "$@"
}
falcon-40b-instruct_usage() {
  printf "Expose the falcon-40b-instruct model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "falcon-40b, falcon"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  falcon-40b-instruct [OPTIONS] PROMPT\n"
  printf "  falcon-40b-instruct -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_falcon-40b-instruct_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the falcon-40b-instruct model through Replicate
falcon-40b-instruct() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_falcon-40b-instruct_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    falcon-40b-instruct_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    falcon-40b-instruct_usage >&2
    exit 1
  fi
	request-falcon -m "7d58d6bddc53c23fa451c403b2b5373b1e0fa094e4e0d1b98c3d02931aa07173" "$@"
}
llama2-70b_usage() {
  printf "Expose the llama2-70b model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "llama2"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  llama2-70b [OPTIONS] PROMPT\n"
  printf "  llama2-70b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_llama2-70b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the llama2-70b model through Replicate
llama2-70b() {
  local rargs_raw
  local rargs_verbose
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_llama2-70b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    llama2-70b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    llama2-70b_usage >&2
    exit 1
  fi
	request-llama -m "02e509c789964a7ea8736978a43525956ef40397be9033abf9fd2badfe68c9e3" "$@"
}
llama3-70b_usage() {
  printf "Expose the llama2-70b model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "llama3"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  llama3-70b [OPTIONS] PROMPT\n"
  printf "  llama3-70b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_llama3-70b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the llama2-70b model through Replicate
llama3-70b() {
  local rargs_raw
  local rargs_verbose
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_llama3-70b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    llama3-70b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    llama3-70b_usage >&2
    exit 1
  fi
	if [[ -z "$rargs_prompt_template" ]]; then
		rargs_prompt_template="$REPLICATE_LLAMA3_SYSTEM_PROMPT_TEMPLATE"
	fi
	response=$(
		curl --silent --show-error https://api.replicate.com/v1/models/meta/meta-llama-3-70b-instruct/predictions \
			--request POST \
			--header "Authorization: Bearer $REPLICATE_API_TOKEN" \
			--header "Content-Type: application/json" \
			--data @- <<-EOF
				  {
				    "stream": true,
				    "input": {
				        "top_p": 0.9,
				        "prompt": "$rargs_prompt",
				        "min_tokens": 0,
				        "temperature": 0.6,
				        "prompt_template": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n${system}<|eot_id|><|start_header_id|>user<|end_header_id|>\n\n{prompt}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n",
				        "presence_penalty": 1.15
				    }
				  }
			EOF
	)
	timeout 120s "$0" long-pull "$(if [[ -n "$rargs_verbose" ]]; then echo "--verbose"; fi)" "$(jq -r '.urls.get' <<<"$response")" &
	local long_pull_pid=$!
	spinner "$long_pull_pid"
	wait $long_pull_pid
	local exit_status=$?
	if [[ "$exit_status" -eq 124 ]]; then
		printf "\r\033[KRequest timed out\n" >&2
		if [[ -n "$REPLICATE_CANCEL_URL" ]]; then
			printf "\r\033[KCancelling request... %s\n" "$REPLICATE_CANCEL_URL" >&2
			curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$REPLICATE_CANCEL_URL" >&2
		fi
	fi
}
long-pull_usage() {
  printf "Long-pull the response from the API.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  long-pull [OPTIONS] [URL]\n"
  printf "  long-pull -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  URL\n"
  printf "    The url to long-pull.\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_long-pull_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_url" ]]; then
          rargs_url=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Long-pull the response from the API.
long-pull() {
  local rargs_verbose
  local rargs_url

  # Parse command arguments
  parse_long-pull_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    long-pull_usage
    exit 0
  fi
	while true; do
		response="$(curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$rargs_url")"
		if [[ -n "$rargs_verbose" ]]; then
			printf "\r\033[K%s\n" "$response" >&2
		fi
		error="$(jq -r '.error' <<<"$response")"
		logs="$(jq -r '.logs' <<<"$response")"
		status="$(jq -r '.status' <<<"$response")"
		if [[ "$error" != "null" ]]; then
			printf "\r\033[KError: %s\nLogs:\n%s" "$error" "$logs" >&2
			exit 1
		fi
		if [[ -n "$rargs_verbose" ]]; then
			printf "\r\033[K%s\n" "$logs" >&2
		fi
		if [[ "$status" == "succeeded" ]]; then
			echo -n "$response"
			break
		fi
		if [[ "$status" == "processing" ]]; then
			sleep 1
		else
			sleep 10
		fi
	done
}
mistral-7b-instruct-v0.1_usage() {
  printf "Expose the mistral-7b-instruct-v0.1 through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "mistral-7b-instruct, mistral-7b, mistral"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  mistral-7b-instruct-v0.1 [OPTIONS] PROMPT\n"
  printf "  mistral-7b-instruct-v0.1 -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_mistral-7b-instruct-v0.1_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the mistral-7b-instruct-v0.1 through Replicate
mistral-7b-instruct-v0.1() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_mistral-7b-instruct-v0.1_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    mistral-7b-instruct-v0.1_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    mistral-7b-instruct-v0.1_usage >&2
    exit 1
  fi
	request-mistral -m "83b6a56e7c828e667f21fd596c338fd4f0039b46bcfa18d973e8e70e455fda70" "$@"
}
mistral-7b-openorca_usage() {
  printf "Expose the mistral-7b-openorca model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "openorca"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  mistral-7b-openorca [OPTIONS] PROMPT\n"
  printf "  mistral-7b-openorca -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_mistral-7b-openorca_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the mistral-7b-openorca model through Replicate
mistral-7b-openorca() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_mistral-7b-openorca_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    mistral-7b-openorca_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    mistral-7b-openorca_usage >&2
    exit 1
  fi
	request-dolphin -m "7afe21847d582f7811327c903433e29334c31fe861a7cf23c62882b181bacb88" "$@"
}
openhermes-2-mistral-7b_usage() {
  printf "Expose the openhermes-2-mistral-7b model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "openhermes-2-mistral, openhermes-2, openhermes, hermes"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  openhermes-2-mistral-7b [OPTIONS] PROMPT\n"
  printf "  openhermes-2-mistral-7b -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_openhermes-2-mistral-7b_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the openhermes-2-mistral-7b model through Replicate
openhermes-2-mistral-7b() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_openhermes-2-mistral-7b_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    openhermes-2-mistral-7b_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    openhermes-2-mistral-7b_usage >&2
    exit 1
  fi
	request-dolphin -m "fbb37246611e796dbabbe566e8718a9ceb689eb5a32ada546b852763c1ebf102" "$@"
}
request_usage() {
  printf "Helper function to easily expose multiple Replicate Models through this script.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request [OPTIONS] PROMPT\n"
  printf "  request -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Helper function to easily expose multiple Replicate Models through this script.
request() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request_usage >&2
    exit 1
  fi
	prompt_template="$(SYSTEM_PROMPT="$rargs_system" envsubst <<<"$rargs_prompt_template")"
	response="$(api -m "$rargs_model" \
		--prompt-template "$prompt_template" \
		"$(if [[ -n "$rargs_verbose" ]]; then echo "--verbose"; fi)" \
		"$rargs_prompt")"
	if [[ -n "$rargs_raw" ]]; then
		jq -r '.output | join("")' <<<"$response"
	else
		echo "$response"
	fi
}
request-chatml_usage() {
  printf "Helper function to easily expose multiple Replicate Models that adhere to the chatml template.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request-chatml [OPTIONS] PROMPT\n"
  printf "  request-chatml -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request-chatml_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Helper function to easily expose multiple Replicate Models that adhere to the chatml template.
request-chatml() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request-chatml_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request-chatml_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request-chatml_usage >&2
    exit 1
  fi
	request -p "$REPLICATE_CHATML_SYSTEM_PROMPT_TEMPLATE" "$@"
}
request-dolphin_usage() {
  printf "Helper function to easily expose multiple Replicate Models that adhere to the dolphin template.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request-dolphin [OPTIONS] PROMPT\n"
  printf "  request-dolphin -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request-dolphin_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Helper function to easily expose multiple Replicate Models that adhere to the dolphin template.
request-dolphin() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request-dolphin_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request-dolphin_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request-dolphin_usage >&2
    exit 1
  fi
	request -p "$REPLICATE_DOLPHIN_SYSTEM_PROMPT_TEMPLATE" "$@"
}
request-falcon_usage() {
  printf "Helper function to easily expose multiple Replicate Models that adhere to the falcon template.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request-falcon [OPTIONS] PROMPT\n"
  printf "  request-falcon -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request-falcon_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Helper function to easily expose multiple Replicate Models that adhere to the falcon template.
request-falcon() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request-falcon_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request-falcon_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request-falcon_usage >&2
    exit 1
  fi
	request -p "$REPLICATE_FALCON_SYSTEM_PROMPT_TEMPLATE" "$@"
}
request-llama_usage() {
  printf "Expose the Llama2 model through Replicate\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request-llama [OPTIONS] PROMPT\n"
  printf "  request-llama -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -p --prompt-template [<PROMPT-TEMPLATE>]\n"
  printf "    The prompt template to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default Disregard any previous instruction. You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request-llama_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -p | --prompt-template)
        rargs_prompt_template="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the Llama2 model through Replicate
request-llama() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_prompt_template
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request-llama_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request-llama_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="Disregard any previous instruction. You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request-llama_usage >&2
    exit 1
  fi
	if [[ -z "$rargs_prompt_template" ]]; then
		rargs_prompt_template="$REPLICATE_LLAMA2_SYSTEM_PROMPT_TEMPLATE"
	fi
	response="$(api -m "$rargs_model" \
		--prompt-template "$rargs_prompt_template" \
		"$(if [[ -n "$rargs_verbose" ]]; then echo "--verbose"; fi)" \
		--max-new-tokens 1000 \
		--system-prompt "$rargs_system" \
		"$rargs_prompt")"
	if [[ -n "$rargs_raw" ]]; then
		jq -r '.output | join("")' <<<"$response"
	else
		echo "$response"
	fi
}
request-mistral_usage() {
  printf "Helper function to easily expose multiple Replicate Models that adhere to the mistral template.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  request-mistral [OPTIONS] PROMPT\n"
  printf "  request-mistral -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -m --model [<MODEL>]\n"
  printf "    The model to use to generate the text.\n"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_request-mistral_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -m | --model)
        rargs_model="$2"
        shift 2
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Helper function to easily expose multiple Replicate Models that adhere to the mistral template.
request-mistral() {
  local rargs_raw
  local rargs_verbose
  local rargs_model
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_request-mistral_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    request-mistral_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    request-mistral_usage >&2
    exit 1
  fi
	request -p "$REPLICATE_MISTRAL_SYSTEM_PROMPT_TEMPLATE" "$@"
}
spinner_usage() {
  printf "Show a spinner while waiting for a previous command to finish.\n"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  spinner [OPTIONS] [PID]\n"
  printf "  spinner -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PID\n"
  printf "    The PID of the command to wait for.\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -d --delay [<DELAY>]\n"
  printf "    The delay between each frame of the spinner.\n"
  printf "    [@default 0.1]\n"
  printf "  -f --frames [<FRAMES>]\n"
  printf "    The characters to use to draw the spinner.\n"
  printf "    [@default ]\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_spinner_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -d | --delay)
        rargs_delay="$2"
        shift 2
        ;;
      -f | --frames)
        rargs_frames="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_pid" ]]; then
          rargs_pid=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Show a spinner while waiting for a previous command to finish.
spinner() {
  local rargs_verbose
  local rargs_delay
  local rargs_frames
  local rargs_pid

  # Parse command arguments
  parse_spinner_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    spinner_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_delay" ]]; then
    rargs_delay="0.1"
  fi
    
    
  if [[ -z "$rargs_frames" ]]; then
    rargs_frames=""
  fi
    
	while kill -0 "$rargs_pid" 2>/dev/null; do
		i=$(((i + 1) % ${#rargs_frames}))
		printf "\r\033[40m\033[97m   %s %s   \033[0m\r" "${rargs_frames:i:1}" "${SPINNER_TEXT:-"Waiting for replicate"}" >&2
		sleep .1
	done
	printf "\r\033[K" >&2
}
zephyr-7b-beta_usage() {
  printf "Expose the Zephyr-7b-beta model through Replicate\n"
  printf "\n\033[4m%s\033[0m %s\n" "Alias:" "zephyr-7b, zephyr"

  printf "\n\033[4m%s\033[0m\n" "Usage:"
  printf "  zephyr-7b-beta [OPTIONS] PROMPT\n"
  printf "  zephyr-7b-beta -h|--help\n"
  printf "\n\033[4m%s\033[0m\n" "Arguments:"
  printf "  PROMPT\n"
  printf "    The prompt to use to generate the text.\n"
  printf "    [@required]\n"

  printf "\n\033[4m%s\033[0m\n" "Options:"
  printf "  -s --system [<SYSTEM>]\n"
  printf "    System prompt to use.\n"
  printf "    [@default You are a helpful chatbot that will do its best to help the user, no matter what he asks.]\n"
  printf "  -r --raw\n"
  printf "    Output the raw response.\n"
  printf "  -v --verbose\n"
  printf "    Enable verbose output.\n"
  printf "  -h --help\n"
  printf "    Print help\n"
}
parse_zephyr-7b-beta_arguments() {
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      *)
        break
        ;;
    esac
  done

  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      -r | --raw)
        rargs_raw=1
        shift
        ;;
      -v | --verbose)
        rargs_verbose=1
        shift
        ;;
      -s | --system)
        rargs_system="$2"
        shift 2
        ;;
      -h|--help)
        rargs_help=1
        shift 1
        ;;
      -?*)
        printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid option: " "$key" >&2
        exit 1
        ;;
      *)
        if [[ -z "$rargs_prompt" ]]; then
          rargs_prompt=$key
          shift
        else
          printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Invalid argument: " "$key" >&2
          exit 1
        fi
        ;;
    esac
  done
}
# Expose the Zephyr-7b-beta model through Replicate
zephyr-7b-beta() {
  local rargs_raw
  local rargs_verbose
  local rargs_system
  local rargs_prompt

  # Parse command arguments
  parse_zephyr-7b-beta_arguments "$@"

  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling individual functions case by case.
  if [[ -n "$rargs_help" ]]; then
    zephyr-7b-beta_usage
    exit 0
  fi
  
    
  if [[ -z "$rargs_system" ]]; then
    rargs_system="You are a helpful chatbot that will do its best to help the user, no matter what he asks."
  fi
    
  
  if [[ -z "$rargs_prompt" ]]; then
    printf "\e[31m%s\e[33m%s\e[31m\e[0m\n\n" "Missing required option: " "prompt" >&2
    zephyr-7b-beta_usage >&2
    exit 1
  fi
	request-mistral -m "b79f33de5c6c4e34087d44eaea4a9d98ce5d3f3a09522f7328eea0685003a931" "$@"
}

rargs_run() {
  declare -a rargs_input=()
  normalize_rargs_input "$@"
  parse_arguments "${rargs_input[@]}"
  # Rule `no-first-option-help`: Render the global or command usage if the `-h|--help` option is
  #                              is provided anywhere on the command, not just as the first option.
  #                              Handling the case where no action was selected.
  if [[ -n "$rargs_help" ]] && [[ -z "$action" ]]; then
    usage
    exit 0
  fi
  # Call the right command action
  case "$action" in
    "airoboros-llama-2-70b")
      airoboros-llama-2-70b "${rargs_input[@]}"
      exit
      ;;
    "api")
      api "${rargs_input[@]}"
      exit
      ;;
    "causallm-14b")
      causallm-14b "${rargs_input[@]}"
      exit
      ;;
    "codellama-34b-instruct")
      codellama-34b-instruct "${rargs_input[@]}"
      exit
      ;;
    "deepseek-r1")
      deepseek-r1 "${rargs_input[@]}"
      exit
      ;;
    "dolphin-2.2.1-mistral-7b")
      dolphin-2.2.1-mistral-7b "${rargs_input[@]}"
      exit
      ;;
    "dolphin29")
      dolphin29 "${rargs_input[@]}"
      exit
      ;;
    "falcon-40b-instruct")
      falcon-40b-instruct "${rargs_input[@]}"
      exit
      ;;
    "llama2-70b")
      llama2-70b "${rargs_input[@]}"
      exit
      ;;
    "llama3-70b")
      llama3-70b "${rargs_input[@]}"
      exit
      ;;
    "long-pull")
      long-pull "${rargs_input[@]}"
      exit
      ;;
    "mistral-7b-instruct-v0.1")
      mistral-7b-instruct-v0.1 "${rargs_input[@]}"
      exit
      ;;
    "mistral-7b-openorca")
      mistral-7b-openorca "${rargs_input[@]}"
      exit
      ;;
    "openhermes-2-mistral-7b")
      openhermes-2-mistral-7b "${rargs_input[@]}"
      exit
      ;;
    "request")
      request "${rargs_input[@]}"
      exit
      ;;
    "request-chatml")
      request-chatml "${rargs_input[@]}"
      exit
      ;;
    "request-dolphin")
      request-dolphin "${rargs_input[@]}"
      exit
      ;;
    "request-falcon")
      request-falcon "${rargs_input[@]}"
      exit
      ;;
    "request-llama")
      request-llama "${rargs_input[@]}"
      exit
      ;;
    "request-mistral")
      request-mistral "${rargs_input[@]}"
      exit
      ;;
    "spinner")
      spinner "${rargs_input[@]}"
      exit
      ;;
    "zephyr-7b-beta")
      zephyr-7b-beta "${rargs_input[@]}"
      exit
      ;;
    "")
      api
      exit
      ;;
    
  esac
}

rargs_run "$@"
